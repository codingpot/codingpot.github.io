<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Okteto 파이프라인(빌드) | 코딩냄비 부글부글</title><meta name=description content="코딩냄비 프로젝트를 진행하며 배운것을 기록합니다."><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="Okteto 파이프라인(빌드)"><meta property="og:description" content="코딩냄비 프로젝트 중 pr12er는 TensorFlow Korea의 논문을 읽고/리뷰하는 모임 PR12에서 촬영된 동영상을 큐레이션하는 프로젝트입니다. 개략적으로 프론트엔드는 Flutter, 백엔드는 GO로 작성되었으며, 이 둘간의 인터페이스는 gRPC/protobuf로 구성되어있습니다. 특히 pr12er 프로젝트의 백엔드 서버는 PR이 Merge 됨과 동시에 Okteto가 제공하는k8s 에 배포되는 CD 루틴을 탑니다.
이 글은 Okteto 에 배포하기위한 파이프라인을 분석하는 총 X 편의 시리즈물 중 첫 번째입니다.
 Okteto 파이프라인 개요, okteto build, pr12er 서버에 대한 Dockerfile 분석 &mldr;&mldr;&mldr;&mldr;&mldr;&mldr;&mldr;&mldr;  Okteto 파이프라인의 개요 말 그대로 Okteto에 원하는 애플리케이션을 배포하는 일련의 과정(파이프라인)을 정의하는 방법입니다."><meta property="og:type" content="article"><meta property="og:url" content="https://codingpot.github.io/cicd/okteto-pipeline-build/"><meta property="article:published_time" content="2021-06-11T00:00:00+00:00"><meta property="article:modified_time" content="2021-06-11T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Okteto 파이프라인(빌드)"><meta name=twitter:description content="코딩냄비 프로젝트 중 pr12er는 TensorFlow Korea의 논문을 읽고/리뷰하는 모임 PR12에서 촬영된 동영상을 큐레이션하는 프로젝트입니다. 개략적으로 프론트엔드는 Flutter, 백엔드는 GO로 작성되었으며, 이 둘간의 인터페이스는 gRPC/protobuf로 구성되어있습니다. 특히 pr12er 프로젝트의 백엔드 서버는 PR이 Merge 됨과 동시에 Okteto가 제공하는k8s 에 배포되는 CD 루틴을 탑니다.
이 글은 Okteto 에 배포하기위한 파이프라인을 분석하는 총 X 편의 시리즈물 중 첫 번째입니다.
 Okteto 파이프라인 개요, okteto build, pr12er 서버에 대한 Dockerfile 분석 &mldr;&mldr;&mldr;&mldr;&mldr;&mldr;&mldr;&mldr;  Okteto 파이프라인의 개요 말 그대로 Okteto에 원하는 애플리케이션을 배포하는 일련의 과정(파이프라인)을 정의하는 방법입니다."><link rel=stylesheet href=https://codingpot.github.io/css/style-white.css><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script><script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=https://codingpot.github.io/images/favicon.ico></head><body class="max-width mx-auto px3 ltr"><div class="content index py4"><header id=header><a href=https://codingpot.github.io/><div id=logo style=background-image:url(https://codingpot.github.io/images/logo.png)></div><div id=title><h1>코딩냄비 부글부글</h1></div></a><div id=nav><ul><li class=icon><a href=# aria-label=Menu><i class="fas fa-bars fa-2x" aria-hidden=true></i></a></li><li><a href=/>Home</a></li><li><a href=/cicd>CI/CD</a></li><li><a href=/mlops>MLOps</a></li></ul></div></header><article class=post itemscope itemtype=http://schema.org/BlogPosting><div class=content itemprop=articleBody><p>코딩냄비 프로젝트 중 <code>pr12er</code>는 TensorFlow Korea의 논문을 읽고/리뷰하는 모임 PR12에서 촬영된 동영상을 큐레이션하는 프로젝트입니다. 개략적으로 프론트엔드는 <code>Flutter</code>, 백엔드는 <code>GO</code>로 작성되었으며, 이 둘간의 인터페이스는 <code>gRPC/protobuf</code>로 구성되어있습니다. 특히 <code>pr12er</code> 프로젝트의 백엔드 서버는 <code>PR</code>이 <code>Merge</code> 됨과 동시에 <code>Okteto</code>가 제공하는<code>k8s</code> 에 배포되는 <code>CD</code> 루틴을 탑니다.</p><p>이 글은 <code>Okteto</code> 에 배포하기위한 파이프라인을 분석하는 총 X 편의 시리즈물 중 첫 번째입니다.</p><ol><li><a href=https://codingpot.github.io/cicd/okteto-pipeline-build/><code>Okteto</code> 파이프라인 개요, <code>okteto build</code>, <code>pr12er</code> 서버에 대한 <code>Dockerfile</code> 분석</a></li><li>&mldr;&mldr;&mldr;&mldr;&mldr;&mldr;&mldr;&mldr;</li></ol><h2 id=okteto-파이프라인의-개요><code>Okteto</code> 파이프라인의 개요</h2><p>말 그대로 <code>Okteto</code>에 원하는 애플리케이션을 배포하는 일련의 과정(파이프라인)을 정의하는 방법입니다. 일반적으로 <code>okteto-pipeline.yaml</code> 이라는 파일로 작성되며, 그 과정은 다음과 같습니다.</p><p>1.애플리케이션에 대한 도커 이미지를 빌드한 후 <code>Okteto</code> 레지스트리에 해당 이미지를 올리는 과정
2.<code>kubectl</code> 명령어로 <code>Deployment</code>, <code>Service</code> 등을 <code>k8s</code> 에 설정</p><h2 id=pr12er에-적용된-okteto-파이프라인-명세서><code>pr12er</code>에 적용된 <code>Okteto</code> 파이프라인 명세서</h2><p>다음은 <code>pr12er</code> 에서 정의한 <code>okteto-pipeline.yaml</code>이며, 이번 게시글에서는 그 중 첫 번째인 <code>okteto build</code> 명령어를 분석합니다.</p><div class=highlight><div style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#5bc4bf>deploy</span>:
  - <span style=color:#f99b15>okteto build -t okteto.dev/codingpot-pr12er-server:${OKTETO_GIT_COMMIT} -f ./server/deploy/Dockerfile server</span>
  - <span style=color:#f99b15>for file in k8s/kkweon-okteto/*.yaml; do envsubst &lt; $file | kubectl apply -f -; done</span>
  - <span style=color:#f99b15>kubectl set image deployment server server=okteto.dev/codingpot-pr12er-server:${OKTETO_GIT_COMMIT}</span>
  - <span style=color:#f99b15>kubectl rollout restart deployment grafana-agent</span>
  - <span style=color:#f99b15>kubectl rollout status deployment server &amp;&amp; kubectl rollout status deployment grafana-agent</span>
</code></pre></td></tr></table></div></div><p>// TODO 전체적인 설명 (매우 간단히)</p><h2 id=okteto-build-명령어><code>okteto build</code> 명령어</h2><p><a href=https://okteto.com/docs/reference/cli#build>공식문서</a>에 따르면 <code>okteto build</code> 명령어는 다음과 같은 일을 합니다. 이 내용을 가지고, 약간의 옵션 플래그를 더한 <code>pre12er</code>용 <code>okteto-pipeline.yaml</code>의 <code>okteto build</code> 가 하는일을 살펴보죠.</p><blockquote><p><code>Dockerfile</code>로부터 이미지를 빌드하여 <code>Okteto</code>의 레지스트리에 등록</p></blockquote><div class=highlight><div style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#5bc4bf>deploy</span>:
  - <span style=color:#f99b15>okteto build -t okteto.dev/codingpot-pr12er-server:${OKTETO_GIT_COMMIT} -f ./server/deploy/Dockerfile server</span>
</code></pre></td></tr></table></div></div><h3 id=-t-옵션><code>-t</code> 옵션</h3><ul><li>빌드될 이미지명과 태그를 설정합니다. 여기서 설정된 이름으로 <code>Okteto</code> 레지스트리에 등록됩니다.</li></ul><h3 id=-f-옵션><code>-f</code> 옵션</h3><ul><li>빌드시 사용할 <code>Dockerfile</code>의 위치(path)를 명시합니다.</li></ul><h3 id=마지막-server>마지막 <code>server</code></h3><ul><li><code>Dockerfile</code>가 빌드할 디렉터리 대상을 지정합니다.</li></ul><p>이를 종합적으로 풀어서 설명하면, <code>server</code> 라는 디렉터리를 참조하여 <code>./server/deploy/</code>에 위치한 <code>Dockerfile</code>로 <code>okteto.dev/codingpot-pr12er-server:${OKTETO_GIT_COMMIT}</code> 라는 이름의 이미지를 빌드하여 <code>Okteto</code> 레지스트리에 등록하라는 뜻이됩니다.</p><h2 id=pr12er-서버용-dockerfile><code>pr12er</code> 서버용 <code>Dockerfile</code></h2><p>그렇다면 <code>Dockerfile</code>은 어떻게 생겼을지도 살펴보겠습니다. 이는 <code>Okteto</code>와는 무관하지만, <code>GO</code> 언어를 사용한 <code>gRPC/protobuf</code> 프로젝트를 위한 기본 골격을 파악하는데 도움이 될 수 있습니다.</p><div class=highlight><div style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#815ba4>FROM</span><span style=color:#48b685> golang:1.16-alpine AS builder</span><span style=color:#ef6155>
</span><span style=color:#ef6155>
</span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> apk --no-cache add ca-certificates <span style=color:#5bc4bf>&amp;&amp;</span> <span style=color:#ef6155>GRPC_HEALTH_PROBE_VERSION</span><span style=color:#5bc4bf>=</span>v0.4.2 <span style=color:#5bc4bf>&amp;&amp;</span> <span style=color:#f99b15>\
</span><span style=color:#f99b15></span>  wget -qO/bin/grpc_health_probe https://github.com/grpc-ecosystem/grpc-health-probe/releases/download/<span style=color:#f99b15>${</span><span style=color:#ef6155>GRPC_HEALTH_PROBE_VERSION</span><span style=color:#f99b15>}</span>/grpc_health_probe-linux-amd64 <span style=color:#5bc4bf>&amp;&amp;</span> <span style=color:#f99b15>\
</span><span style=color:#f99b15></span>  chmod +x /bin/grpc_health_probe<span style=color:#ef6155>
</span><span style=color:#ef6155>
</span><span style=color:#ef6155></span><span style=color:#815ba4>WORKDIR</span><span style=color:#48b685> /src/</span><span style=color:#ef6155>
</span><span style=color:#ef6155></span><span style=color:#815ba4>COPY</span> go.mod .<span style=color:#ef6155>
</span><span style=color:#ef6155></span><span style=color:#815ba4>COPY</span> go.sum .<span style=color:#ef6155>
</span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> go mod download<span style=color:#ef6155>
</span><span style=color:#ef6155></span><span style=color:#815ba4>COPY</span> . .<span style=color:#ef6155>
</span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> <span style=color:#ef6155>CGO_ENABLED</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>0</span> <span style=color:#ef6155>GOOS</span><span style=color:#5bc4bf>=</span>linux go build -ldflags <span style=color:#48b685>&#34;-w -s&#34;</span> -o server cmd/server/main.go<span style=color:#ef6155>
</span><span style=color:#ef6155>
</span><span style=color:#ef6155></span><span style=color:#815ba4>FROM</span><span style=color:#48b685> gcr.io/distroless/static:nonroot</span><span style=color:#ef6155>
</span><span style=color:#ef6155>
</span><span style=color:#ef6155></span><span style=color:#815ba4>COPY</span> --from<span style=color:#5bc4bf>=</span>builder /src/server .<span style=color:#ef6155>
</span><span style=color:#ef6155></span><span style=color:#815ba4>COPY</span> --from<span style=color:#5bc4bf>=</span>builder /bin/grpc_health_probe /bin/grpc_health_probe<span style=color:#ef6155>
</span><span style=color:#ef6155>
</span><span style=color:#ef6155></span><span style=color:#815ba4>ENTRYPOINT</span> [<span style=color:#48b685>&#34;./server&#34;</span>]<span style=color:#ef6155>
</span></code></pre></td></tr></table></div></div><p>우선 <code>FROM</code>이라는 지시자는 새로운 빌드 스테이지를 초기화하며, 이어지는 지시자가 적용될 대상 베이스 이미지로 설정합니다. 상기 <code>Dockerfile</code>에는 <code>FROM</code> 지시자가 두 개 등장하는 데, 이는 빌드 스테이지가 여러개임을 뜻합니다. <strong>첫 번째</strong> <code>FROM</code>의 이미지에서 작업된 내역을 <strong>두 번째</strong> <code>FROM</code>으로 전달하여 최종 이미지는 <strong>두 번째</strong>의것이 되는것이죠. 이 방식은 주로 애플리케이션을 컴파일/빌드하기 위한 여러가지 디펜던시를 담아 애플리케이션의 컴파일/빌드를 수행한 다음, 해당 애플리케이션의 실행 가능한 바이너리 파일만을 <strong>경량</strong> 이미지에 옮겨 이미지의 사이즈를 최소화하는 데 많이 활용됩니다.</p><ul><li><code>golang:1.16-alpine</code> 이미지는 <a href=https://hub.docker.com/_/alpine><code>alpine</code></a> 이라는 리눅스 배포판에 기초하여 <code>GO</code> 언어까지가 함께 설치된 것입니다.</li><li><a href=https://github.com/GoogleContainerTools/distroless><code>gcr.io/distroless/static:nonroot</code></a> 는 오로지 구동될 애플리케이션과 런타임 디펜던시만을 포함하고, 기타 일반적인 리눅스에서 제공하는 다양한 패키지(쉘 포함)를 제외한 초경량 이미지입니다.</li></ul><p>그렇다면 두 <code>FROM</code> 사이에서 첫 번째 <code>FROM</code>이 해야할 일은 명확합니다. 애플리케이션을 빌드한 바이너리 파일, 그리고 그 애플리케이션을 구동하는 데 필요한 런타임 디펜던시를 구축하는 것이죠. 그렇게 구축된것을 두 번째 <code>FROM</code>에 심어주기 위함입니다.</p><h3 id=workdir-src><code>WORKDIR /src/</code></h3><ul><li>첫 번째 <code>FROM</code> 이미지에서 작업할 디렉터리를 지정합니다.</li></ul><h3 id=copy-gomod--copy-gosum-><code>COPY go.mod .</code>, <code>COPY go.sum .</code></h3><ul><li>프로젝트에 필요한 모듈 디펜던시와 각 디펜던시에 대한 체크섬이 명시된 두 파일을 현재 작업 디렉터리로 복사합니다.</li><li><code>COPY</code> 지시자의 첫 번째 인자는 앞서 지정된 <code>server</code> 라는 디렉터리를 기준으로 복사될 파일명을 명시하며, 두 번째 인자는 파일이 복사되어 저장될 이미지내 디렉터리를 명시합니다(즉 <code>WORKDIR</code>).</li></ul><h3 id=run-go-mod-download><code>RUN go mod download</code></h3><ul><li>디펜던시에대한 명세서만 있을 뿐, 현재 이미지에는 해당 디펜던시가 없기 때문에, 명세서를 참조하여 모듈을 다운로드 받습니다.</li></ul><h3 id=copy--><code>COPY . .</code></h3><ul><li>디펜던시 외 프로젝트를 구동하는데 필요한 모든 파일을 복사합니다.</li></ul><h3 id=run--go-build---o-server-cmdservermaingo><code>RUN ... go build ... -o server cmd/server/main.go</code></h3><ul><li>이후 <code>go build</code> 명령어로 <code>cmd/server/main.go</code> 라는 파일을 바이너리 파일로 빌드하고, 그 바이너리 파일의 이름을 <code>server</code>라고 명명합니다.</li></ul><p>이제 구동될 애플리케이션을 빌드하였으니, 실제 애플리케이션 구동에 필요없는 파일들(소스 파일 등)을 제외하고 두 번째 <code>FROM</code> 이미지로 복사합니다. 이 과정은 실제 이미지가 올라갔을 때 최초로 실행되는 지점인 <code>ENTRYPOINT</code> 지시자 이전까지에 해당합니다.</p><h3 id=copy---frombuilder-srcserver->COPY &ndash;from=builder /src/server .</h3><ul><li><code>--from=builder</code> 라는 플래그가 새롭게 추가된 <code>COPY</code> 지시자 입니다. 앞서 첫 번째 <code>FROM</code> 지시자에서 <code>as builder</code> 라고 적은것은 나중에 해당 빌드 스테이지를 참조하기위한 별칭을 지정한 것입니다.</li><li>따라서 <code>builder</code> 스테이지에서 <code>go build</code>로 만들어진 바이너리 파일인 <code>server</code>를 현재 이미지에 복사한다는 뜻이됩니다. 이때 <code>/src/server</code>인 이유는 첫 번째 스테이지에서 작업 디렉터리가 <code>/src/</code>로 지정되어, 만들어진 <code>server</code> 바이너리 파일이 <code>/src/</code> 디렉터리내 위치하기 때문입니다.</li></ul><h3 id=copy---frombuilder-bingrpc_health_probe-bingrpc_health_probe>COPY &ndash;from=builder /bin/grpc_health_probe /bin/grpc_health_probe</h3><ul><li><code>grpc_health_probe</code>는 <code>gRPC</code> 서버의 실행여부를 판단하는 데 쓰이는 유틸리티 프로그램입니다. 이 프로그램은 첫 번째 빌드 스테이지 중 <code>RUN</code> 지시자에서 <code>wget</code>을 통해 다운로드 받은것을 그대로 복사한 것입니다.</li><li>두 번째 스테이지에서 다운로드 받지 <strong>못한</strong> 이유는 초경량 이미지여서 <code>wget</code> 명령어조차 들어있지 않기 때문입니다.</li></ul></div></article><footer id=footer><div class=footer-left>Copyright &copy; 2021 코딩냄비</div><div class=footer-right><nav><ul><li><a href=/>Home</a></li><li><a href=/cicd>CI/CD</a></li><li><a href=/mlops>MLOps</a></li></ul></nav></div></footer></div></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script><script src=/js/main.js></script></html>